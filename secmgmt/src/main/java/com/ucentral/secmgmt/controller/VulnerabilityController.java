package com.ucentral.secmgmt.controller;

import com.ucentral.secmgmt.model.Vulnerability;
import com.ucentral.secmgmt.service.VulnerabilityLoaderService;
import com.ucentral.secmgmt.service.VulnerabilityService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@CrossOrigin(origins ={"http://localhost:4200"} )
@RestController
@RequestMapping("/vulnerabilities")
public class VulnerabilityController {

    @Autowired
    private VulnerabilityLoaderService vulnerabilityLoaderService;

    @Autowired
    private VulnerabilityService vulnerabilityService;

    @GetMapping("/index")
    public List<Vulnerability> listar() {
        return vulnerabilityService.listVulnerabilities();

    }
    @PostMapping("/index")
    @ResponseStatus(HttpStatus.CREATED)
    public Vulnerability saveVulnerabilities(@RequestBody Vulnerability vulnerability) {
        return vulnerabilityService.saveVulnerabilities(vulnerability);
    }
    @GetMapping("/index/{id}")
    public Vulnerability listVulnerability (@PathVariable Long id) {
        return vulnerabilityService.findVulnerabilitybyId(id);
    }

    @PutMapping("/index/{id}")
    @ResponseStatus(HttpStatus.CREATED)
    public Vulnerability actualizarVulnerability(@RequestBody Vulnerability vulnerability, @PathVariable Long id){
        Vulnerability vulnerabilityActual = vulnerabilityService.findVulnerabilitybyId(id);
        vulnerabilityActual.setName(vulnerability.getName());
        vulnerabilityActual.setRisk(vulnerability.getRisk());
        vulnerabilityActual.setSynopsis(vulnerability.getSynopsis());
        vulnerabilityActual.setDescription(vulnerability.getDescription());
        vulnerabilityActual.setPluginOutut(vulnerability.getPluginOutut());
        vulnerabilityActual.setVulnerabilityState(vulnerability.getVulnerabilityState());
        return vulnerabilityService.saveVulnerabilities(vulnerabilityActual);
    }
    @DeleteMapping("/index/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void eliminarVulnerability(@PathVariable Long id) { vulnerabilityService.deleteVulnerability(id);}


    @PostMapping("/load-from-excel")
    public ResponseEntity<Map<String, String>> loadVulnerabilitiesFromExcel(@RequestParam("file") MultipartFile file) {
        try {
                File excelFile = convertMultipartFileToFile(file);
                vulnerabilityLoaderService.loadVulnerabilities(excelFile);
                Map<String, String> response = new HashMap<>();
                response.put("status", "success");
                response.put("message", "Archivo CSV cargado exitosamente.");
                return ResponseEntity.ok(response);//.body("Vulnerabilities loaded successfully.");
            } catch (IOException e) {
            Map<String, String> response = new HashMap<>();
            response.put("status", "error");
            response.put("message", "Error al cargar el archivo: " + e.getMessage());

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
            }
        }
       private File convertMultipartFileToFile(MultipartFile file) throws IOException {
            File convertedFile = new File(file.getOriginalFilename());
            FileOutputStream fos = new FileOutputStream(convertedFile);
            fos.write(file.getBytes());
            fos.close();
            return convertedFile;
        }
}