package com.ucentral.secmgmt.service;

import com.ucentral.secmgmt.model.Device;
import com.ucentral.secmgmt.model.Management;
import com.ucentral.secmgmt.model.Vulnerability;
import com.ucentral.secmgmt.repository.VulnerabilityRepository;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;





@Service
public class VulnerabilityLoaderService2 {
    @Autowired
    private DeviceService deviceService; // Inyectar DeviceService en lugar de DeviceRepository
    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;
    @Autowired
    private ManagementService managementService;
    public void loadVulnerabilitiesFromExcel(File file) throws IOException {
        FileInputStream inputStream = new FileInputStream(file);
        Workbook workbook = new XSSFWorkbook(inputStream);
        Sheet sheet = workbook.getSheetAt(0);

        for (Row row : sheet) {
            if (row.getRowNum() == 0) {
                continue;
            }

            boolean rowHasData = false;
            for (int i = 0; i < row.getLastCellNum(); i++) {
                Cell cell = row.getCell(i);
                if (cell != null && cell.getCellType() != CellType.BLANK) {
                    rowHasData = true;
                    break; // Si se encuentra al menos una celda no vacía, la fila tiene datos
                }
            }

            if (!rowHasData) {
                continue; // Saltar la fila si no contiene datos significativos
            }


            String risk = getStringValue(row.getCell(3));
            String hostname = getStringValue(row.getCell(4));
            String name = getStringValue(row.getCell(7));
            String synopsis = getStringValue(row.getCell(8));
            String description = getStringValue(row.getCell(9));
            String pluginOutput = getStringValue(row.getCell(12));
            String vulnerabilityState = getStringValue(row.getCell(14));
            String ipAddress = getStringValue(row.getCell(15));
            String loadedDateTimeString = getStringValue(row.getCell(30));

            Device device = deviceService.findDeviceByIpAddress(ipAddress);

            if (device != null) {
                // Crear una instancia de Vulnerability con los datos obtenidos
                Vulnerability vulnerability = new Vulnerability();
                vulnerability.setHostname(hostname);
                vulnerability.setRisk(risk);
                vulnerability.setName(name);
                vulnerability.setSynopsis(synopsis);
                vulnerability.setDescription(description);
                vulnerability.setPluginOutut(pluginOutput);
                Date loadedDateTime = convertStringToDate(loadedDateTimeString);
                vulnerability.setLoadedDateTime(loadedDateTime);
                vulnerability.setVulnerabilityState(vulnerabilityState);
                vulnerability.getDevices().add(device);

            // Guardar la vulnerabilidad en la base de datos
            vulnerabilityRepository.save(vulnerability);

            Management management = new Management();
            management.setVulnerabilidad(vulnerability);

            managementService.saveManagement(management);
            } else {
                System.out.println("Dispositivo con dirección IP " + ipAddress + " no encontrado. Omitiendo la carga de esta vulnerabilidad.");
            }
        }
        workbook.close();
        inputStream.close();
    }


    private String getStringValue(Cell cell) {
        if (cell != null) {
            switch (cell.getCellType()) {
                case STRING:
                    return cell.getStringCellValue();
                case NUMERIC:
                    // Handle numeric cells (check if it's a date format)
                    if (DateUtil.isCellDateFormatted(cell)) {
                        Date date = DateUtil.getJavaDate(cell.getNumericCellValue(), false); // Use appropriate date conversion method
                        return new SimpleDateFormat("yyyy-MM-dd").format(date); // Format date as needed
                    } else {
                        // If not a date format, treat it as a string
                        return Double.toString(cell.getNumericCellValue());
                    }
                case BOOLEAN:
                    return Boolean.toString(cell.getBooleanCellValue());
                case FORMULA:
                    return cell.getCellFormula();
                case ERROR:
                    return "[ERROR]";
                case BLANK:
                    return "";
                default:
                    return ""; // Handle other cell types (if necessary)
            }
        }
        return "";
    }
    private Date convertStringToDate(String loadedDateTimeString) {
        if (loadedDateTimeString == null || loadedDateTimeString.isEmpty()) {
            // Handle empty string (e.g., return null, log a warning, etc.)
            return null;
        }

        try {
            // Use a SimpleDateFormat with only year, month, and day format
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
            Date date = formatter.parse(loadedDateTimeString);
            return date;
        } catch (ParseException e) {
            // Handle parsing exceptions appropriately (e.g., log the error)
            e.printStackTrace();
            return null;
        }
    }
    private static final String[] SUPPORTED_DATE_FORMATS = {
            "yyyy-MM-dd", // ISO 8601 format
            "dd/MM/yyyy", // European format
            "MM-dd-yyyy", // American format
            // Add other supported formats as needed
    };
}