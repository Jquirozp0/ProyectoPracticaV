package com.ucentral.secmgmt.service;

import org.apache.commons.io.FilenameUtils;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.ucentral.secmgmt.model.Device;
import com.ucentral.secmgmt.model.Management;
import com.ucentral.secmgmt.model.Vulnerability;
import com.ucentral.secmgmt.repository.VulnerabilityRepository;
import com.ucentral.secmgmt.service.DeviceService;
import com.ucentral.secmgmt.service.ManagementService;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
@Service
public class VulnerabilityLoaderService {
    @Autowired
    private DeviceService deviceService;
    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;
    @Autowired
    private ManagementService managementService;

    public void loadVulnerabilities(File file) throws IOException {
        String extension = FilenameUtils.getExtension(file.getName());

        if (extension.equalsIgnoreCase("csv")) {
            loadVulnerabilitiesFromCSV(file);
        } else if (extension.equalsIgnoreCase("xlsx")) {
            loadVulnerabilitiesFromExcel(file);
        } else {
            throw new IllegalArgumentException("Formato de archivo no soportado. Solo se admiten archivos CSV y XLSX.");
        }
    }

   /* private void loadVulnerabilitiesFromCSV(File file) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            String[] headers = null;

            // Leer la fila de encabezados
            if ((line = reader.readLine()) != null) {
                headers = line.split(",");
            }

            // Leer las filas de datos
            while ((line = reader.readLine()) != null) {
                String[] values = line.split(",");

                // Obtener los índices de las columnas (ajusta según tu CSV)
                int ipIndex = findIndex(headers, "IP");
                int severityIndex = findIndex(headers, "Severity");
                int nvtNameIndex = findIndex(headers, "NVT Name");
                int summaryIndex = findIndex(headers, "Summary");
                int solutionIndex = findIndex(headers, "Solution");
                int vulnerabilityInsightIndex = findIndex(headers, "Vulnerability Insight");
                int hostnameIndex = findIndex(headers, "Hostname");

                // Validar que se encontraron todos los índices
                if (ipIndex != -1 && severityIndex != -1 && nvtNameIndex != -1 &&
                        summaryIndex != -1 && solutionIndex != -1 && vulnerabilityInsightIndex != -1 &&
                        hostnameIndex != -1) {

                    // Extraer los valores y crear la entidad Vulnerability
                    String ipAddress = values[ipIndex];
                    String risk = values[severityIndex];
                    String name = values[nvtNameIndex];
                    String synopsis = values[summaryIndex];
                    String description = values[vulnerabilityInsightIndex];
                    String hostname = values[hostnameIndex];

                    Vulnerability vulnerability = new Vulnerability();
                    vulnerability.setHostname(hostname);
                    vulnerability.setRisk(risk);
                    vulnerability.setName(name);
                    vulnerability.setSynopsis(synopsis);
                    vulnerability.setDescription(description);
                    vulnerability.setVulnerabilityState("activa");

                    // Asociar el dispositivo y guardar la vulnerabilidad
                    Device device = deviceService.findDeviceByIpAddress(ipAddress);
                    if (device != null) {
                        vulnerability.getDevices().add(device);
                        vulnerabilityRepository.save(vulnerability);

                        // Crear y guardar la entidad Management
                        Management management = new Management();
                        management.setVulnerabilidad(vulnerability);
                        managementService.saveManagement(management);
                    } else {
                        // Manejar el caso en que no se encuentra el dispositivo
                        System.out.println("Dispositivo con IP " + ipAddress + " no encontrado.");
                    }
                } else {
                    System.out.println("Error: No se encontraron todos los encabezados requeridos en el CSV.");
                }
            }
        }
    }*/

    private void loadVulnerabilitiesFromCSV(File file) throws IOException {
        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
            String line;
            String[] headers = null;

            // Read the header row
            if ((line = reader.readLine()) != null) {
                headers = line.split(",");
            }

            // Read data rows
            while ((line = reader.readLine()) != null) {
                String[] values = line.split(",");

                // Obtain column indices (adjust based on your CSV)
                int ipIndex = findIndex(headers, "IP");
                int severityIndex = findIndex(headers, "Severity");
                int nvtNameIndex = findIndex(headers, "NVT Name");
                int summaryIndex = findIndex(headers, "Summary");
                int solutionIndex = findIndex(headers, "Solution");
                int vulnerabilityInsightIndex = findIndex(headers, "Vulnerability Insight");
                int hostnameIndex = findIndex(headers, "Hostname");

                // Validate required headers
                if (ipIndex == -1 || severityIndex == -1 || nvtNameIndex == -1) {
                    System.out.println("Error: Missing required headers in CSV.");
                    continue; // Skip to the next line
                }

                // Extract values (handle empty fields)
                String ipAddress = values.length > ipIndex ? values[ipIndex].trim() : ""; // Trim potential whitespace
                String risk = values.length > severityIndex ? values[severityIndex].trim() : "";
                String name = values.length > nvtNameIndex ? values[nvtNameIndex].trim() : "";
                String synopsis = values.length > summaryIndex ? values[summaryIndex].trim() : "";
                String description = values.length > vulnerabilityInsightIndex ? values[vulnerabilityInsightIndex].trim() : "";
                String hostname = values.length > hostnameIndex ? values[hostnameIndex].trim() : "";

                // Create Vulnerability object (handle empty fields)
                Vulnerability vulnerability = new Vulnerability();
                vulnerability.setHostname(ipAddress.isEmpty() ? null : ipAddress); // Set null for empty IP
                vulnerability.setRisk(risk);
                vulnerability.setName(name);
                vulnerability.setSynopsis(synopsis);
                vulnerability.setDescription(description);
                vulnerability.setVulnerabilityState("activa");

                // Associate device and save vulnerability (handle missing device)
                Device device = deviceService.findDeviceByIpAddress(ipAddress);
                if (device != null) {
                    vulnerability.getDevices().add(device);
                    vulnerabilityRepository.save(vulnerability);

                    // Create and save Management entity
                    Management management = new Management();
                    management.setVulnerabilidad(vulnerability);
                    managementService.saveManagement(management);
                } else {
                    System.out.println("Device with IP " + ipAddress + " not found.");
                }
            }
        } // BufferedReader automatically closes upon exiting the try block
    }
    public void loadVulnerabilitiesFromExcel(File file) throws IOException {
        FileInputStream inputStream = new FileInputStream(file);
        Workbook workbook = new XSSFWorkbook(inputStream);
        Sheet sheet = workbook.getSheetAt(0);

        for (Row row : sheet) {
            if (row.getRowNum() == 0) {
                continue;
            }

            boolean rowHasData = false;
            for (int i = 0; i < row.getLastCellNum(); i++) {
                Cell cell = row.getCell(i);
                if (cell != null && cell.getCellType() != CellType.BLANK) {
                    rowHasData = true;
                    break; // Si se encuentra al menos una celda no vacía, la fila tiene datos
                }
            }

            if (!rowHasData) {
                continue; // Saltar la fila si no contiene datos significativos
            }


            String risk = getStringValue(row.getCell(3));
            String hostname = getStringValue(row.getCell(4));
            String name = getStringValue(row.getCell(7));
            String synopsis = getStringValue(row.getCell(8));
            String description = getStringValue(row.getCell(9));
            String pluginOutput = getStringValue(row.getCell(12));
            String vulnerabilityState = getStringValue(row.getCell(14));
            String ipAddress = getStringValue(row.getCell(15));
            String loadedDateTimeString = getStringValue(row.getCell(30));

            Device device = deviceService.findDeviceByIpAddress(ipAddress);

            if (device != null) {
                // Crear una instancia de Vulnerability con los datos obtenidos
                Vulnerability vulnerability = new Vulnerability();
                vulnerability.setHostname(hostname);
                vulnerability.setRisk(risk);
                vulnerability.setName(name);
                vulnerability.setSynopsis(synopsis);
                vulnerability.setDescription(description);
                vulnerability.setPluginOutut(pluginOutput);
                Date loadedDateTime = convertStringToDate(loadedDateTimeString);
                vulnerability.setLoadedDateTime(loadedDateTime);
                vulnerability.setVulnerabilityState(vulnerabilityState);
                vulnerability.getDevices().add(device);

                // Guardar la vulnerabilidad en la base de datos
                vulnerabilityRepository.save(vulnerability);

                Management management = new Management();
                management.setVulnerabilidad(vulnerability);

                managementService.saveManagement(management);
            } else {
                System.out.println("Dispositivo con dirección IP " + ipAddress + " no encontrado. Omitiendo la carga de esta vulnerabilidad.");
            }
        }
        workbook.close();
        inputStream.close();
    }

    private String getStringValue(Cell cell) {
        if (cell != null) {
            switch (cell.getCellType()) {
                case STRING:
                    return cell.getStringCellValue();
                case NUMERIC:
                    // Handle numeric cells (check if it's a date format)
                    if (DateUtil.isCellDateFormatted(cell)) {
                        Date date = DateUtil.getJavaDate(cell.getNumericCellValue(), false); // Use appropriate date conversion method
                        return new SimpleDateFormat("yyyy-MM-dd").format(date); // Format date as needed
                    } else {
                        // If not a date format, treat it as a string
                        return Double.toString(cell.getNumericCellValue());
                    }
                case BOOLEAN:
                    return Boolean.toString(cell.getBooleanCellValue());
                case FORMULA:
                    return cell.getCellFormula();
                case ERROR:
                    return "[ERROR]";
                case BLANK:
                    return "";
                default:
                    return ""; // Handle other cell types (if necessary)
            }
        }
        return "";
    }
    private Date convertStringToDate(String loadedDateTimeString) {
        if (loadedDateTimeString == null || loadedDateTimeString.isEmpty()) {
            // Handle empty string (e.g., return null, log a warning, etc.)
            return null;
        }

        try {
            // Use a SimpleDateFormat with only year, month, and day format
            SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");
            Date date = formatter.parse(loadedDateTimeString);
            return date;
        } catch (ParseException e) {
            // Handle parsing exceptions appropriately (e.g., log the error)
            e.printStackTrace();
            return null;
        }
    }
    private static final String[] SUPPORTED_DATE_FORMATS = {
            "yyyy-MM-dd", // ISO 8601 format
            "dd/MM/yyyy", // European format
            "MM-dd-yyyy", // American format
            // Add other supported formats as needed
    };
    private int findIndex(String[] headers, String header) {
        for (int i = 0; i < headers.length; i++) {
            if (headers[i].equalsIgnoreCase(header)) {
                return i;
            }
        }
        return -1;
    }
}